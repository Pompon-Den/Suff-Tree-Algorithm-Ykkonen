# Suff Tree Algorithm Ykkonen
- Рыжков Данил Максимович.
- Вуз  - Двфу.
- Направление - Б9121-09.03.03пикд.
- Год - 2022.
- Алгоритм - Построение суффисного дерева алгоритмом Укконена.

----------------------------------------------------------
# Содержание
- [Глоссарий]
- [Вступление]
     - [Задача Online поиск шаблонов в тексте]
     - [Основная идея алгоритма заключается в нескольких модификациях]
     - [Как же предобработать текст?]
- [Основополагающая идея: построить суффиксное дерево(бор на суффиксах)]
- [Сжатое Суффиксное дерево]
- [Построение сжатого суффиксного дерева]
    - [Алгоритм]
    - [Операция добавления символа]
- [Положения]
  - [Первый тип]
  - [Второй тип]
  - [Третий тип]
  - [Изменение типов]
- [Переход от положения к положению:Суффиксная ссылка]
  - [Как создавать суффиксные ссылки?]
  - [Рассмотрим применение суффиксных ссылок]
- [Структура дерева]
- [Реалицазия]    
    - [Конструктор Узла]
    - [Деструктор]
    - [Функция построения дерева]
    - [Расширение суффиксного дерева]
- [Список литературы]

------------------------------------------------
## Глоссарий
- __`Строка (text)`__ – это последовательность символов, взятых из заранее определенного алфавита. Каждый символ алфавита имеет свой уникальный номер.
- __`Подстрока`__ – это часть строки, состоящая из некоторого количества смежных символов исходной строки.
- __`Префикс`__ - это подстрока строки __S__  заканчивающеяся в позиции __i__, т.е это подстрока __S[1..i]__.
- __`Суффикс`__ - это подстрока строки __S__, начинающеяся в позиции __i__ и зканчивающеяся в __m__ - где __m__ это длина строки __S__. Представляется как __S[i..m]__.
Например суффиксы строки __"abcab"__ представлены ниже в таблице.
 
    | Индекс |Суффикс|
    | ------ |:-----:|
    |    0   | abcab |
    |    1   | bcab |
    |    2   | cab |
    |    3   | ab |
    |    4   | b |
    |    5   | ""|

- __`Суффиксный дерево(бор на суффиксах`__ - дерево, содержащие все суффиксы некоторой строки (и только их).
                                                  Позволяет выяснять, входит ли строка w в исходную строку t, за время О (|w|), где |w| — длина подстроки w.
- **`Сжатое суффиксное дерево`** - это некоторая оптимизация несжатого дерева, в котором структуру из нескольких
                                         последовательных вершин, выглядящих как односвязный список, заменяют на одно ребро .
- **`Конкатенация`** — операция склеивания объектов линейной структуры, обычно строк. 
                             Например, конкатенация слов «микро» и «мир» даст слово «микромир».
- **`Суффиксная ссылка`** - Пусть __xα__ обозначает произвольную строку, где __x__ — её первый символ,
                                а __α__ — оставшаяся подстрока (возможно пустая).
                                Если для внутренней вершины v с путевой меткой xα существует другая вершина __s(v)__ с путевой меткой __α__,
                                то ссылка из __v__ в __s(v)__ называется суффиксной ссылкой.
- __`Итерация`__ — способ организации обработки данных, при котором определенные действия повторяются многократно,
                    не приводя при этом к рекурсивным вызовам программ. 


----------------------------------------
## Вступление
***Алгоритм Укконена*** — это онлайн-алгоритм построения суффиксного дерева за линейным время,
 который изобрел Эско Укконен в 1995 году.

Алгоритм, который изобрел Эско Укконен для построения суффиксного дерева за линейное время можно представить сначала как простой,
 но неэффективный метод, который с помощью нескольких приёмов достигает уровня лучших алгоритмов по времени счёта в наихудших условиях.

Позже были изобретены другие, более эффективные алгоритмы, например обновленный алгоритм Питера Вайнера, создателя суффиксных деревьев.

Понять как  работает алгоритм поможет постановка задачи.

#### Задача Online поиск шаблонов в тексте
Дан некоторый текст, который можно прочитать и предобработать.Дан ряд подстрок.

 Требуется за длину подстроки  __***O***(|P|)__ сказать,
 находиться ли он в тексте, и если да, то на какой позиции. При этом мы не хотим просматривать заново текст.

---------------------------
#### Основная идея алгоритма заключается в нескольких модификациях
- Использование Сжатого суффиксного дерева.
- Хранить подстроки не полностью, а лишь их  индексы начала и конца относительно исходной строки.
- Использованние суффиксных ссылок.
----------------------------------

#### Как же предобработать текст?
Для начала стоит понять, что подстрока - это префикс суффикса.
Например имеется строка - **"abcaf"**,  подстрока "ca" является префиксом **"ca"** суффикса **"caf"**.

Отсюда вытекает идея каким то образом закодировать все суффиксы текста,
чтобы быстро можно было проверить подстроку, является ли она перфиксом какого-либо суффикса текста.


Число суффиксов текста равно длине самого текста, это следует из определения суффикса. 

--------------------------------------------

#### Основополагающая идея: построить суффиксное дерево(бор на суффиксах)

<center> 

![Альтернативный текст](Image\First.jpg "суффиксное дерево")
</center> 

Размер у такой структуры слишком большой, чтоб быстро отвечать на запрос поиска подстроки.
Возникает вопрос, как уменьшить данную структуру?

Перестроем суффиксное дерево в сжатое суффиксное дерево. Для начала все внутреннии вершины у которых один ребёнок уберём
 и поместим на одну дугу символы, которые в них хранились.Теперь на ребрах хранятся подстроки исходного текста.
Для уменьшения по затратам памяти, хранить их будем в виде **[start...end]**,
 где **start** - начало подстроки в тексте, **end** - конец подстроки в тексте.
<center> 

![Альтернативный текст](Image\Second.jpg "сжатое суффиксное дерево")
</center> 

Линейный ли размер у данной структуры? Заметим, что листьев может быть не больше чем суффиксов,
 то есть ***O(|T|)***. Следовательно внутренних вершин не более чем ***O(|T| - 1)***, а так как подстроки мы храним в виде пары индексов
 значит размер данной структуры линейный.


------------------------

#### Сжатое Суффиксное дерево
- ` Сжатое Суффиксное дерево для m-символьной строки S` — это ориентированное дерево с корнем,
 имеющее ровно m листьев, занумерованных от 1 до m. Каждая внутренняя вершина, отличная от корня,
 имеет не меньше двух детей, а каждая дуга помечена непустой подстрокой строки S (дуговой меткой).
 Никакие две дуги, выходящие из одной и той же вершины, не могут иметь пометок, начинающихся с одного
 и того же символа. Главная особенность суффиксного дерева заключается в том,
 что для каждого листа конкатенация меток дуг на пути от корня к листу i в точности составляет (произносит) суффикс строки S,
 который начинается в позиции i. То есть этот путь произносит S[i..m]. 

Но определение суффиксного дерева для S не гарантирует, что такое дерево действительно существует для любой строки S.
 Трудность состоит в том, что если один суффикс совпадает с префиксом другого суффикса,
 то построить суффиксное дерево, удовлетворяющее данному выше определению, невозможно,
 поскольку путь для первого суффикса не сможет закончиться в листе.


Например, если удалить последний символ из строки ‘xabxac’, образовав строку ‘xabxa’,
 то суффикс ‘ха’ будет префиксом суффикса ‘xabxa’, так что путь, произносящий ‘ха’,
 не будет заканчиваться в листе.
Во избежание этой трудности предполагается, что последний символ строки S нигде больше в строку не входит.


При таком условии никакой суффикс строки не сможет быть префиксом другого суффикса. Чтобы обеспечить это на практике,
 можно добавить в конце строки S какой-либо символ, не входящий в основной алфавит. Чаще всего используется символ ‘$’.

----------------------------------------------
## Построение сжатого суффиксного дерева

Для начала рассмотрим положения в дереве:
<center> 

![Альтернативный текст](Image\3.jpg "Положения")
</center> 

Можно заметить, что положения суффиксов бывают неявными, чтобы это исправить построим дерево для
 конкатенации исходной строки и терминального символа **$$S +"TERMINATION_SYMBOL"$$**.
В качестве которого должен быть символ не встречающийся в строке, обычно используют **"$"**.

Тогда дерево принимает вид:
<center> 

![Альтернативный текст](Image\4.jpg "Положения")
</center> 

------------------------------------

#### Алгоритм
- Начинаем с пустого дерева.
- На каждом шаге добавляем очередной символ строки.
- На i-ом шаге удлинняются i  суффиксов

<center> 

![Альтернативный текст](Image\5.jpg "Положения")
</center> 

Итераций - в простонародье шагов, будет линейное количество - длина строки.

-----------------------------------------

#### Операция добавления символа
- Требуется добавить символ **"a"** к **i** суффиксам.
- На **i**-ой итерации символ нужно добавить в **i** положений в дереве.
- Перебираем эти  положения в порядке уменьшения глубины.

Переход между положениями осуществляется с помощью суффиксных ссылок и будет рассмотрен в дальнейшем.
<center> 

![Альтернативный текст](Image\6.jpg "Положения")
</center> 

Для удобства ребра будут называться дугами.

Рассмотрим три случая вставки нового символа:
1. Мы находимся в листе, в таком случае продлеваем лист.
2. Положение без символа **"a"** в начале исходящих дуг, в таком случае эти положения нужно преобразовать, добавим новые дуги. Неявные положения станут явными, а к явным добавиться новый лист.
3. Положение с символом **"a"** в начале исходящих дуг,в таком случае ничего не добавляем.

---------------------------------------
## Положения
#### Первый тип

<center> 

![Альтернативный текст](Image\7,1.jpg "Положения")
</center> 

При добавлении символа в лист, нам достаточно расширить дугу которая в этой лист идёт,
 а так как это лист то в нем заканчивается один из суффиксов текущей части строки т.е __i__,
 соответсвенно при расширении **i** увеличивается на 1.

Заметим,что первый тип всегда преобразуется в самого себя т.е на каждой итерации мы удлинеям существующие листы.
Чтобы ускорить данную операцию, можно воспользоваться указателями.

Пусть переменная ***end** будет указателем.Так же создадим глобальную переменную **LeafEnd** и будем увеличчиввать её на 1 каждом шаге.
Тогда если при создании листов на дуге будет сохранена __*end = &leafEnd__ это позволит расшиирять дугу неявным образом.
 Так как __&__ обращается к адресу в памяти, а __\*__ преобразует его в хранящееся по этому адресу число.

Таким образом листья можно не трогать.

-----------------------------------------
#### Второй тип

При втором типе, мы так или иначе добавляем новую вершину, а так как вершин у  линейное количество,
 это даёт надежду на построение алгоритма за линейное время.

------------------------------------------

#### Третий тип

Изменять дерево не требуется. Продвигаемся вперед по строке.

Т.к мы перебираем положения в порядке уменьшения глубины то заметим, что номера типов положений не убывают:**« 1,..., 1, 2,...,2, 3,..., 3 »**.
Значит как только встретили положение типа 3, можем переходить к следующей итерации.

Почему это так?

<center> 

![Альтернативный текст](Image\8.jpg "Положения")
</center> 

Раз мы перебираем положения от более глубоких к менее глубоким, то при переходе мы попадаем в суффикс короче на один символ.
Исходя из этого утверждается, что если у дуги **aβ**, есть продолжение то у дуги **β** оно тоже есть.
Т.е если  **aβ** не явлется листом, то **β** тоже не является листом.

--------------------------------------

#### Изменение типов

<center> 

![Альтернативный текст](Image\9.jpg "Положения")
</center> 

Как было подмеченно ранее, положения типа 1 и 2 изменяются в положения типа 1, а вот положение типа 3, может привести нас к любому типу.
Положений типа 2 у нас линейное количество,но положений типа один может встретиться неопределенное количество.

Поэтому докажем,что суммарно всех положений которые нам предстоит пройти будет линейное количество от длины строки.
Для этого введем понятие **Потенциал**, которое определяется как символьнаая глубина,она же в свою очередь означает самое глубокое положение на итерации.
- Таким образом образом потенциал будет уменьшаться на 1 при переходе в следующему положению в итерации, поскольку глубина положения изменится на 1.
- Увеличиваться же потенциал будет на 1 при переходе на следующую итерацию, поскольку глубина в таком случае увеличивается на 1 символ.
- Следовательно мы посетим линейное количетво положений.

----------------------------------------------------


## Переход от положения к положению:Суффиксная ссылка

Также нам понадобится понятие суффиксной ссылки. Она определена для внутренних явершин дерева. 
Переход по суффиксной ссылке будет вести в вершину, соответствующую той же строке, но без первого символа.
Для корня суффиксная ссылка не определена.

-----------------------------------------------
#### `Лемма`

Для любой внутренней вершины v суффиксного дерева существует суффиксная ссылка,
 ведущая в некоторую внутреннюю вершину u.

-------------------------------------------------
#### `Доказательство`

Рассмотрим внутреннюю вершину v с путевой меткой **s[start…i]**. Так как эта вершина внутренняя,
 её путевая метка ветвится справа в исходной строке.
 Тогда очевидно подстрока **s[start+1…i]** тоже ветвится справа в исходной строке,
 и ей соответствует некоторая внутренняя вершина **u**.
 По определению суффиксная ссылка вершины **v** ведёт в **u**.

------------------------------------------

#### Как создавать суффиксные ссылки?

Для вершин положение которых типа 1, суффиксная ссылка не изменяется.

Для положения типа 2, поскольку образуется новая вершина, мы запоминаем существующую суффиксную ссылку,
 чтобы в дальнейшем испльзуя её создать у новой вершины суффиксную ссылку.
И когда на **i**-ой итерации создаётся новая(не первая) вершина для этой итерации, то она сойденяется с созданной до этого вершиной суффиксной ссылкой.

Легко увидеть, что в процессе построения суффиксного дерева уже построенные суффиксные ссылки никак не изменяются.
 Поэтому осталось сказать, как построить суффиксные ссылки для созданных вершин.
 Рассмотрим новую внутреннюю вершину **v**, которая была создана в результате продления суффикса **S[start…i−1]**.
 Вместо того, чтобы искать, куда должна указывать суффиксная ссылка вершины **v**, поднимаясь от корня дерева для этого,
 перейдем к продлению следующего суффикса **S[start+1…i−1]**. И в этот момент можно проставить суффиксную ссылку для вершины **v**.
 Она будет указывать либо на существующую вершину, если следующий суффикс закончился в ней, либо на новую созданную.
 То есть суффиксные ссылки будут обновляться с запаздыванием. Внимательно посмотрев на все три правила продления суффиксов,
 можно осознать, что для вершины v точно найдётся на следующей фазе внутренняя вершина, в которую должна вести суффиксная ссылка.

<center> 

![Альтернативный текст](Image\10.png "Переход по суффиксным ссылкам")
 </center>


#### Рассмотрим применение суффиксных ссылок

 Пусть только что был продлён суффикс **S[start…i−1]** до суффикса **S[start…i]**.
 Теперь с помощью построенных ссылок можно найти конец суффикса **S[start+1…i−1]** в суффиксном дереве,
 чтобы продлить его до суффикса **S[start+1…i]**. Для этого надо пройти вверх по дереву до ближайшей внутренней вершины **v**,
 в которую ведёт путь, помеченный **S[start…r]**. У вершины **v** точно есть суффиксная ссылка (о том, как строятся суффиксные ссылки,
 будет сказано позже, а пока можно просто поверить). Эта суффиксная ссылка ведёт в вершину **u**, которой соответствует путь,
 помеченный подстрокой **S[start+1…r]**. Теперь от вершины **u** следует пройти вниз по дереву к концу суффикса **S[start+1…i−1]**
 и продлить его до суффикса **S[start+1…i]**.

Подстрока **S[start+1…i−1]** является суффиксом подстроки **S[start…i−1]**, следовательно после перехода по суффиксной ссылке в вершину,
 помеченную путевой меткой **S[start+1…r]**, можно дойти до места, которому соответствует метка **S[r+1…i−1]**,
 сравнивая не символы на рёбрах, а лишь длину ребра по первому символу рассматриваемой части подстроки и длину самой этой подстроки.
 Таким образом можно спускаться вниз сразу на целое ребро.



------------------------------
## Структура дерева

- __`#define TERMINATION_SYMBOL '$'`__ уникальный символ который гарантирует что никакой суффикс не будет являться префиксом какого-либо другого суффикса.

#### Вершина(узел) суффиксного дерева включает в себя:
 - __`map<char, Node*> children`__ - "массив" детей.
 -  __`Node* suffix_link`__ - суффиксная ссылка.
 -   __`int start`__ - номер первого символа вершины в исходной строке.
 -   __`int* end`__ - номер последнего символа вершины в исходной строке .
 -   __`int suffix_index`__ - номер суффикса.
-------------------------------------------------
#### Дерево хранит  себе:
- __`Node* root`__ - корень
- __`Node* lastCreatedInternalNode`__ - последняя созданная внутренняя вершина.
- __`Node* activeNode`__ - вершина с которой  начнется расширение на следующей фазе.
- __`int activeEdge`__ -  индекс символа, который задает движение из текущей ноды
- __`int activeLength`__ - на сколько символов ступаем в направлении activeEdge
- __`int remainingSuffixCount`__ - сколько суффиксов осталось создать. по сути, сколько суффиксов на прошлом шаге мы не создали.
- __`int leafEnd`__ -  глобальная переменная, определяет содержимое листьев: её инкремент как бы приписывает новый символ к ним.

#### Функции:
- __`SuffixTree(string& text)`__ - конструктор по строке.
- __`void BuildSuffixTree()`__ - само построение дерева.
- __`~SuffixTree()`__ - деструктор.
- __`void DeleteSuffixTree(Node* node)`__ - удаление дерева.
- __`void ExtendSuffixTree(int pos)`__ - расширение дерева, по другому построение дерева.
- __`int EdgeLength(Node* node)`__  - подсчет длины подстроки расположенной на дуге.  
-------------------------------------------------------------------------------

## Реалицазия
 #### Конструктор Узла
```c++
    Node(Node* link, int start, int* end) : Node(link, start, end, -1)
    {
    // конструктор ноды без индекса: используется при создании новых внутренних вершин
    }

    Node(Node* link, int start, int* end, int ind) : suffix_link(link),
        start(start),
        end(end),
        suffix_index(ind)
    {
    // конструктор с индексом: используется при создании листьев
    // ибо при их создании можно доподлинно определить их индекс
    }
```
#### Деструктор 
```c++
~SuffixTree()                         
    {
        DeleteSuffixTree(root);
    }

void DeleteSuffixTree(Node* node)
    {
        for (auto it : node->children)
            DeleteSuffixTree(it.second);
        if (node->suffix_index == -1)
            delete node->end;
        delete node;
    }
```
#### Функция построения дерева
```c++
SuffixTree(string& str) : text(str)
{
    text += TERMINATION_SYMBOL;
    BuildSuffixTree();
}

void BuildSuffixTree()
{
    activeNode = root; //в самом начале корень и будет местом расширения
    for (size_t i = 0; i < text.length(); i++)
        ExtendSuffixTree(i); // рассмотрена отдельно
}
```
#### Расширение суффиксного дерева

```c++
void SuffixTree::ExtendSuffixTree(int phase)
{
    // установить lastCreatedInternalNode = null перед началом каждой фазы
    lastCreatedInternalNode = nullptr;

    // глобальный end для листьев
    // инкремент leafEnd воплощает правило 1,  наращивание листьев
    leafEnd++;

    // сколько суффиксов осталось создать
    remainingSuffixCount++;

    while (remainingSuffixCount > 0)
    {
        // если activeLength равна 0, тогда ищем текущий символ из корня
        if (activeLength == 0)
            activeEdge = phase; // индекс текущего символа в тексте определяет дугу, по которой будем двигаться

        // ищем текущий символ в начале исходящих из activeNode дуг
        auto find = activeNode->children.find(text[activeEdge]);

        // не нашли
        if (find == activeNode->children.end())
        {
            // добавим новую листовую дугу, исходящую из activeNode, начинающуся текущим символом (под листовой дугой имеется ввиду ребро)
            activeNode->children.insert(make_pair(
                text[activeEdge],
                new Node(root, phase, &leafEnd, phase - remainingSuffixCount + 1)));
            // и коль скоро создали новую внутр. вершинку, установим на нее суфф-Ссылку последней созданной внутренней вершины (Правило 2)
            if (lastCreatedInternalNode != nullptr)
            {
                lastCreatedInternalNode->suffix_link = activeNode;
                lastCreatedInternalNode = nullptr;
            }
        }
        else
        {
            // а если-таки есть дуга из activeNode, начинающаяся текущим символом, пойдем по ней спускаться
            Node* next = find->second;
            int edge_length = EdgeLength(next); // нашли длину дуги(ребра)

            // спуск по дуге(-ам)
            if (activeLength >= edge_length)
            {
                activeEdge += edge_length;
                activeLength -= edge_length;
                activeNode = next;
                continue; // таким образом мы будем спускаться, покуда не станет activeLength < edge_length
            }

            // правило 3: если текущий символ есть на дуге,
            // т.е. суффикс уже есть в дереве, то просто увеличим activeLength
            // как бы "шагнем вперед" по дуге
            if (text[next->start + activeLength] == text[phase])
            {
                // если lastCreatedInternalNode != null
                // это означает, что 2-е правило было применено ранее (создание новой внутренней  вершины)
                // установим суффлинку в activeNode
                if (lastCreatedInternalNode != nullptr && activeNode != root)
                    lastCreatedInternalNode->suffix_link = activeNode;
                activeLength++;
                break; // выйдем из цикла while
            }

            // сюда попали, если текущего символа нет на дуге
            // создадим новую внутреннюю вершинку
            Node* split = new Node(root, next->start, new int(next->start + activeLength - 1));
            // подвесим к activeNode новую вершинку
            activeNode->children[text[activeEdge]] = split;
            // у "следующей" вершинки изменим, очевидно, начало, ибо мы ее "обрубили"
            next->start += activeLength;
            // подвесим новую листовую вершинку
            split->children.insert(make_pair(text[phase], new Node(root, phase, &leafEnd, phase - remainingSuffixCount + 1)));
            // подвесим отрубленную вершинку
            split->children.insert(make_pair(text[next->start], next));
            // и не забудем про установку ссылок при создании новой внутренней вершины
            if (lastCreatedInternalNode != nullptr)
                lastCreatedInternalNode->suffix_link = split;
            lastCreatedInternalNode = split;
        }

        remainingSuffixCount--;

        // если activeNode == root, тогда согласно правилу 2, мы декементируем activeLength и инкрементируем activeEdge
        // это, можно сказать, альтернатива суфф. ссылке в случае, когда activeNode == root
        if (activeNode == root && activeLength > 0)
        {
            activeLength--;
            activeEdge++;
        }
        else if (activeNode != root) // если же activeNode != root, то радостно скачем по имеющейся суффиксной ссылке
            activeNode = activeNode->suffix_link;
    }
}
```

## Список литературы

- [Реализация алгоритмов/Алгоритм Укконена](https://ru.wikibooks.org/wiki/Реализации_алгоритмов/Алгоритм_Укконена "")
- [Вики-Итмо](https://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Укконена)
- [Статья об Алгоритме на Хабре](https://habr.com/ru/post/111675/)
- Юрий Лифшиц - Построение суффиксного дерева за линейное время.
- Укконен Э. (1995)  "Онлайн-построение деревьев суффиксов".
- Вайнер, Питер (1973). "Алгоритмы линейного сопоставления с образцом".
- [Реализация Алгоритма Укконена](https://e-maxx.ru/algo/ukkonen)
- [Алгоритм Укконена: от простого к сложному](https://habr.com/ru/post/533774/)
- Гасфилд Д. Строки, деревья и последовательности в алгоритмах: Информатика и вычислительная биология / Пер. с англ. И. В. Романовского. — 2-е изд. — СПб.: Невский Диалект, 2003. — 654 с.
- [Павел Марвин Лекция по суффиксным деревьям ИТМО](https://www.youtube.com/watch?v=WjzR1eFbAeo)
- [Алгоритм построения суффиксных деревьев](https://u4isna5.ru/diplom/20-diplominformatika/470-2012-02-13-18-54-40)
- [Статья на CodeWork](https://codeforces.com/blog/entry/16780)
- [Лекция от Computer Science Centre](https://www.youtube.com/watch?v=wyFvEECgsWs&t=828s)
- [Лекция от Технологии в контуре](https://www.youtube.com/watch?v=kxqlaynGgEA&t=3022s)
- [Статья на stackoverflow](https://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english/9513423#9513423)
- [Подробное объяснение алгоритма](https://www.youtube.com/watch?v=aPRqocoBsFQ)
- [Основополагающая лекция](https://compscicenter.ru/courses/algorithms-2/nsk/2018-spring/classes/3764/)





